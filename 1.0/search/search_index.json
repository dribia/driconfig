{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DriConfig","text":"CI/CD Package <p> A Pydantic-ish way to manage your project's YAML configurations. </p> <p>Documentation: https://dribia.github.io/driconfig</p> <p>Source Code: https://github.com/dribia/driconfig</p> <p>The usage of YAML files to store configurations and parameters is widely accepted in the Python community, especially in Data Science environments.</p> <p>DriConfig provides a clean interface between your Python code and these YAML configuration files.</p> <p>It is heavily based on Pydantic's Settings Management, preserving its core functionalities and advantages.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Subclassing the <code>DriConfig</code> class we create an interface to any YAML configuration file.</li> <li>Our project's configurations are then attributes of this class.</li> <li>They are automatically filled with the values in the YAML configuration file.</li> <li>We can define complex configuration structures using Pydantic models.</li> <li>We preserve Pydantic's type casting and validation!</li> </ul>"},{"location":"#example","title":"Example","text":"<p>Let's say we have a YAML configuration file <code>config.yaml</code> with the following data: <pre><code># config.yaml\nmodel_parameters:\n  eta: 0.2\n  gamma: 2\n  lambda: 1\n\ndate_interval:\n  start: 2021-01-01\n  end: 2021-12-31\n</code></pre> Then we can configparse with <code>driconfig</code> as follows: <pre><code>from datetime import date\nfrom typing import Dict\n\nfrom driconfig import DriConfig, DriConfigConfigDict\nfrom pydantic import BaseModel\n\n\nclass DateInterval(BaseModel):\n  \"\"\"Model for the `date_interval` configuration.\"\"\"\n  start: date\n  end: date\n\n\nclass AppConfig(DriConfig):\n   \"\"\"Interface for the config/config.yaml file.\"\"\"\n\n    \"\"\"Configure the YAML file location.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n   model_parameters: Dict[str, float]\n   date_interval: DateInterval\n\nconfig = AppConfig()\nprint(config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"model_parameters\": {\n        \"eta\": 0.2,\n        \"gamma\": 2.0,\n        \"lambda\": 1.0\n    },\n    \"date_interval\": {\n        \"start\": \"2021-01-01\",\n        \"end\": \"2021-12-31\"\n    }\n}\n\"\"\"\n</code></pre></p>"},{"location":"contribute/","title":"Contribute","text":"<p> Contributions to Dribia libraries are always welcome! </p>"},{"location":"contribute/#mantainers","title":"Mantainers","text":"<p>DriConfig is maintained by Dribia Data Research code@dribia.com.</p>"},{"location":"contribute/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues.</p> <p>Please note which version of the library are you using whenever reporting a bug. <pre><code>python -c \"import driconfig; print(driconfig.__version__)\"\n</code></pre></p> <p>It would be very useful too to know which OS and Python version are your running DriConfig from.</p>"},{"location":"contribute/#contribute_1","title":"Contribute","text":"<p>In order to contribute, the first step is to clone yourself the code: repository: <pre><code>git clone https://github.com/dribia/driconfig.git\n</code></pre> Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: <pre><code>poetry install &amp;&amp; pre-commit install\n</code></pre></p> <p>Now you should be ready to start coding and prepare your pull request.</p> <p>Remember that you can run linting and tests locally with:</p> <pre><code>make lint\nmake test\n</code></pre> <p>Happy coding!</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#pip","title":"PIP","text":"<p>Installation is as simple as: <pre><code>pip install driconfig\n</code></pre> DriConfig heavily depends on two other Python libraries, that will be installed as dependencies:</p> <ul> <li>Pydantic is a data validation framework using Python type annotations.</li> <li>PyYAML is a full-featured YAML framework for the Python programming language.</li> </ul>"},{"location":"usage/configdict/","title":"ConfigDict","text":""},{"location":"usage/configdict/#pydantics-configdict-dictionary","title":"Pydantic's ConfigDict dictionary","text":"<p>A Pydantic model's internal <code>ConfigDict</code> dictionary controls many aspects of its functionality. An exhaustive list can be found in Pydantic's documentation.</p> <p>The <code>DriConfigConfigDict</code> dictionary, as it inherits from Pydantic's <code>BaseModel</code>, has all these configuration options available.</p> <p>However, we have added some new configuration options, and modified some of its defaults.</p>"},{"location":"usage/configdict/#driconfigconfigdicts-dictionary","title":"DriConfigConfigDict's dictionary.","text":""},{"location":"usage/configdict/#new-configurations","title":"New configurations","text":"Field Type (default) Description <code>config_folder</code> <code>str</code> (<code>\"config\"</code>) Path to the folder where the YAML file is placed. <code>config_file_name</code> <code>str</code> (<code>\"config.yaml\"</code>) YAML file name. <code>config_file_encoding</code> <code>Optional[str]</code> (<code>None</code>) YAML file encoding. If <code>None</code>, the <code>PyYAML</code> default is used. <code>config_prefix</code> <code>str</code> (<code>\"\"</code>) Prefix for configuration variable names. <code>case_sensitive</code> <code>bool</code> (<code>False</code>) Whether to be case sensitive when reading variables from the YAML configuration file. <p>Tip</p> <p>The <code>config_prefix</code> is useful when working with environments, so that configurations can be named e.g. after <code>DEV_</code>, <code>PRE_</code> or <code>PRO_</code> prefixes, but accessed with their root names within the code.</p> <p>Note that the prefix only affects first-level names in the YAML file. Names in nested configurations should not be prefixed.</p> <p><pre><code># config.yaml\n\nPRE_PARENT_CONFIG:\n    CHILD_CONFIG_A: 1\n    CHILD_CONFIG_B: 1.2\n</code></pre> <pre><code># main.py\n\nfrom typing import Dict\n\nfrom driconfig import DriConfig, DriConfigConfigDict\n\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n        config_prefix = \"PRE_\",\n    )\n\n    PARENT_CONFIG: Dict[str, float]\n\n\napp_config = AppConfig()\nprint(app_config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"PARENT_CONFIG\": {\n        \"CHILD_CONFIG_A\": 1.0,\n        \"CHILD_CONFIG_B\": 1.2\n    }\n}\n\"\"\"\n</code></pre></p>"},{"location":"usage/configdict/#modified-configurations","title":"Modified configurations","text":"Field Type (default) Description <code>validate_default</code> <code>bool</code> (<code>True</code>) Defaults to <code>True</code> so that validation is done in YAML file parsing. <code>arbitrary_types_allowed</code> <code>bool</code> (<code>True</code>) Allow arbitrary types by default. <code>extra</code> <code>str</code> (<code>forbid</code>) Forbid extra arguments on initialization by default."},{"location":"usage/introduction/","title":"Introduction","text":"<p>DriConfig mimics Pydantic's Settings Management functionality, working with YAML configurations instead of environment variables or <code>.env</code> files.</p>"},{"location":"usage/introduction/#the-yaml-language","title":"The YAML language","text":"<p>YAML is a human-readable data-serialization language, commonly used for configuration files. It natively encodes scalars (such as strings, integers, and floats), lists, and dictionaries.</p> <pre><code># config.yaml\n\nparameter_a: \"some string\"\nparameter_b: 1\nparameter_c: 1.2\nparameter_d: [\"I'm\", \"a\", \"list\"]\n</code></pre> <p>The above code block contains a sample configuration file written in the YAML language.</p> <p>Info</p> <p>If you want to run the rest of the code blocks in this document, place the contents of the previous one into a file called <code>config.yaml</code> in your working directory.</p> <p>Tip</p> <p>A YAML configuration file should always be a dictionary at its first level. The elements of this dictionary, then, could be of any type (scalars, lists or dictionaries).</p> <p>The goal of DriConfig is to provide an interface between your Python code and such YAML confguration files.</p>"},{"location":"usage/introduction/#the-driconfig-class","title":"The DriConfig class","text":"<p>DriConfig provides a base configuration class called <code>DriConfig</code>. This base class should be sub-classed in order to generate custom configuration classes that represent YAML configuration files.</p> <pre><code>from driconfig import DriConfig\n\nclass AppConfig(DriConfig):  # Inherits the base DriConfig class.\n    \"\"\"Empty configuration class.\"\"\"\n\n    pass\n\napp_config = AppConfig()\n\nprint(app_config.model_dump_json())\n\"\"\"\n{}\n\"\"\"\n</code></pre>"},{"location":"usage/introduction/#the-driconfigs-driconfigconfigdict-dictionary","title":"The DriConfig's DriConfigConfigDict dictionary","text":"<p>Now, we would want to read and parse the <code>config.yaml</code> file we created before. We need to configure our <code>AppConfig</code> class in order to point at that file.</p> <pre><code>from driconfig import DriConfig, DriConfigConfigDict\n\nclass AppConfig(DriConfig):\n    \"\"\"Empty configuration class.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\napp_config = AppConfig()\n\nprint(app_config.model_dump_json())\n\"\"\"\n{}\n\"\"\"\n</code></pre> <p>Warning</p> <p>In Pydantic V2, to specify config on a model, you should set a class attribute called model_config to be a dict with the key/value pairs you want to be used as the config. The Pydantic V1 behavior to create a class called Config in the namespace of the parent <code>BaseModel</code> subclass is now deprecated.</p> <p>Note</p> <p>We have extended the use of Pydantic <code>ConfigDict</code> dictionary to host the YAML file information. In the ConfigDict section we detail which configurations have been added or modified.</p>"},{"location":"usage/introduction/#parsing-yaml-configurations","title":"Parsing YAML configurations","text":"<p>Now we would want to parse the configurations we put on our <code>config.yaml</code> file.</p> <pre><code>from typing import List\n\nfrom driconfig import DriConfig, DriConfigConfigDict\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\n    parameter_a: str\n    parameter_b: int\n    parameter_c: float\n    parameter_d: List[str]\n\napp_config = AppConfig()\n\nprint(app_config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"parameter_a\": \"some string\",\n    \"parameter_b\": 1,\n    \"parameter_c\": 1.2,\n    \"parameter_d\": [\n        \"I'm\",\n        \"a\",\n        \"list\"\n    ]\n}\n\"\"\"\n</code></pre> <p>Note how we declared the configuration variable types following Pydantic's syntax. In fact, while parsing the <code>config.yaml</code> file DriConfig is performing type validation, so that if your configuration variable value is of an undesired type it will raise a validation error.</p> <pre><code>from driconfig import DriConfig, DriConfigConfigDict\nfrom pydantic import ValidationError\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\n    parameter_a: int\n\ntry:\n    app_config = AppConfig()\nexcept ValidationError as e:\n    print(e)\n\"\"\"\n1 validation error for AppConfig\nparameter_a\n  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='some string', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.2/v/int_parsing\n\"\"\"\n</code></pre> <p>As you can guess, all the benefits from Pydantic are hold by the <code>DriConfig</code> base class. Then, apart from raising errors on incorrect types, values are casted to the correct type when possible, and even nested configurations can be expressed as nested Pydantic models.</p> <p>In particular, also the default values behavior is preserved from Pydantic. This is, we could define a default value for a given configuration, so that if the configuration is not present in the YAML configuration file, it gets the default value from the configuration class definition.</p> <pre><code>from typing import List\n\nfrom driconfig import DriConfig, DriConfigConfigDict\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\n    parameter_a: str\n    parameter_b: int\n    parameter_c: float\n    parameter_d: List[str]\n    parameter_e: str = \"default value\"\n\napp_config = AppConfig()\n\nprint(app_config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"parameter_a\": \"some string\",\n    \"parameter_b\": 1,\n    \"parameter_c\": 1.2,\n    \"parameter_d\": [\n        \"I'm\",\n        \"a\",\n        \"list\"\n    ],\n    \"parameter_e\": \"default_value\n}\n\"\"\"\n</code></pre> <p>Now, if we add <code>parameter_e</code> to our <code>config.yaml</code> file: <pre><code># config.yaml\n\nparameter_a: \"some string\"\nparameter_b: 1\nparameter_c: 1.2\nparameter_d: [\"I'm\", \"a\", \"list\"]\nparameter_e: \"custom value\"\n</code></pre> We see how it prevails over the default value: <pre><code>from typing import List\n\nfrom driconfig import DriConfig, DriConfigConfigDict\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\n    parameter_a: str\n    parameter_b: int\n    parameter_c: float\n    parameter_d: List[str]\n    parameter_e: str = \"default value\"\n\napp_config = AppConfig()\n\nprint(app_config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"parameter_a\": \"some string\",\n    \"parameter_b\": 1,\n    \"parameter_c\": 1.2,\n    \"parameter_d\": [\n        \"I'm\",\n        \"a\",\n        \"list\"\n    ],\n    \"parameter_e\": \"custom value\"\n}\n\"\"\"\n</code></pre></p>"},{"location":"usage/nested_models/","title":"Nested models","text":"<p>Being able to use Pydantic models to parse nested configurations on our YAML files is maybe the strongest point of DriConfig.</p> <p>Let's say we have a YAML <code>config.yaml</code> file looking like this:</p> <pre><code># config.yaml\n\ntimeout: 1000\nmin_date: 2021-04-17\nmodel_parameters:\n  alpha: 2\n  beta: 0.1\n  gamma: 30\n</code></pre> <p>In this case, <code>model_parameters</code> is what we call a nested configuration, being a dictionary of dictionaries.</p> <p>Then, we would have two options:</p> <ul> <li>Parse <code>model_parameters</code> as a <code>dict</code> type.</li> <li>Parse it as a Pydantic model, and performing specific type validation for each of its values.</li> </ul>"},{"location":"usage/nested_models/#arbitrary-types","title":"Arbitrary types","text":"<p>Let's parse the <code>model_parameters</code> configuration as an arbitrary dictionary. <pre><code>from datetime import date\nfrom typing import Any, Dict\n\nfrom driconfig import DriConfig, DriConfigConfigDict\n\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\n    timeout: int\n    min_date: date\n    model_parameters: Dict[str, Any]\n\napp_config = AppConfig()\nprint(app_config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"timeout\": 1000,\n    \"min_date\": \"2021-04-17\",\n    \"model_parameters\": {\n        \"alpha\": 2,\n        \"beta\": 0.1,\n        \"gamma\": 30\n    }\n}\n\"\"\"\nprint(type(app_config.model_parameters))\n\"\"\"\n&lt;class 'dict'&gt;\n\"\"\"\n</code></pre></p> <p>Note that no type validation is performed on the values of <code>model_paramters</code>. Instead, it is stored as an arbitrary dictionary.</p>"},{"location":"usage/nested_models/#nested-model","title":"Nested model","text":"<p>Now, let's properly parse <code>model_parameters</code> as a Pydantic model. <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\nfrom driconfig import DriConfig, DriConfigConfigDict\n\n\nclass ModelParameters(BaseModel):\n    \"\"\"Pydantic model for `model_parameters`.\"\"\"\n\n    alpha: int\n    beta: float\n    gamma: int\n\n\nclass AppConfig(DriConfig):\n    \"\"\"Configuration class to parse the config.yaml file contents.\"\"\"\n\n    \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\"\n    model_config = DriConfigConfigDict(\n        config_folder=\".\",\n        config_file_name=\"config.yaml\",\n    )\n\n    timeout: int\n    min_date: date\n    model_parameters: ModelParameters\n\napp_config = AppConfig()\nprint(app_config.model_dump_json(indent=4))\n\"\"\"\n{\n    \"timeout\": 1000,\n    \"min_date\": \"2021-04-17\",\n    \"model_parameters\": {\n        \"alpha\": 2,\n        \"beta\": 0.1,\n        \"gamma\": 30\n    }\n}\n\"\"\"\nprint(type(app_config.model_parameters))\n\"\"\"\n&lt;class '__main__.ModelParameters'&gt;\n\"\"\"\n</code></pre></p> <p>Note how, in this case, type validation is performed for <code>alpha</code>, <code>beta</code> and <code>gamma</code>.</p> <p>We could mimic this pattern to build even deeper nested configuration parsers, holding all of Pydantic's validation power.</p>"}]}